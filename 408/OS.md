## Operating System

### 系统调用
系统调用分用户态（进程）和系统态（系统调用：IO，文件管理...）。

### 进程间通信方法
1. 管道(pipe)：半双工，父子进程间通信
2. 有名管道(named pipe)：半双工，任意进程间通信
3. 消息队列(message queue)：全双工，任意进程间通信
4. 共享内存(shared memory)：全双工，任意进程间通信
5. 信号(signal)：异步通信，任意进程间通信
6. 套接字(socket)：全双工，任意进程间通信
7. 信号量(semaphore)：用于进程同步，解决临界区问题

### 进程调度算法
1. 先来先服务(FCFS, First-Come, First-Served)
2. 短作业优先(SJF, Shortest Job First)
3. 优先级调度(Priority Scheduling)
4. 时间片轮转(RR, Round Robin)
5. 多级反馈队列(Multilevel Feedback Queue)

### 内存管理
1. 分块：早期的内存管理方式
2. 分页：将内存分为固定大小的页
3. 分段：有意义的逻辑信息

### 分页查找
1. 快表：加速虚拟地址到物理地址的转换
2. 多级页表：减少页表大小，避免把全部页表加载到内存

### 为什么要虚拟内存
直接暴露物理内存会带来以下问题：
1. 内存保护：防止进程访问其他进程的内存
2. 内存共享：允许多个进程共享相同的内存区域
3. 内存扩展：允许进程使用比物理内存更大的地址
4. 内存碎片：减少内存碎片，提高内存利用率

### 页面置换算法
所访问的页面不在内存中发生缺页中断。

1. FIFO（先进先出）
2. LFU（最近最久未使用）
3. LRU（最近最少使用）
4. OPT（最佳置换）：之理论上最优，但不可实现

### inode
储存文件信息的结构体，包含文件类型、权限、所有者、大小、时间戳和数据块指针等。

### 软连接和硬连接
1. 硬连接：多个文件名指向同一个inode，不能跨文件
2. 软连接：文件名指向另一个文件的路径，可以跨文件系统

## IO 多路复用
IO 多路复用是一种同步IO模型，实现一个线程可以监视多个文件句柄；  
一旦某个文件句柄就绪，就能够通知应用程序进行相应的读写操作；  
没有文件句柄就绪就会阻塞应用程序，交出CPU。

### 同步阻塞 BIO
服务端采用单线程，当 accept 一个请求后，在 recv 或 send 调用阻塞时，将无法 accept 其他请求（必须等上一个请求处理 recv 或 send 完 ）（无法处理并发）

服务端采用多线程，当 accept 一个请求后，开启线程进行 recv，可以完成并发处理，但随着请求数增加需要增加系统线程，大量的线程占用很大的内存空间，并且线程切换会带来很大的开销，10000个线程真正发生读写实际的线程数不会超过20%，每次accept都开一个线程也是一种资源浪费。


### 同步非阻塞 NIO
服务器端当 accept 一个请求后，加入 fds 集合，每次轮询一遍 fds 集合 recv (非阻塞)数据，没有数据则立即返回错误，每次轮询所有 fd （包括没有发生读写实际的 fd）会很浪费 CPU。

### IO 多路复用
[video](https://www.bilibili.com/video/BV1RJ4m1b7cy/?spm_id_from=333.337.search-card.all.click&vd_source=cad68d53a48573461e83be27a70101d1)

服务器端采用单线程通过 select/poll/epoll 等系统调用获取 fd 列表，遍历有事件的 fd 进行 accept/recv/send ，使其能支持更多的并发连接请求。

### IO 多路复用的实现
1. select：Linux 内核 2.4 之前的版本，支持的文件描述符数量有限（1024），每次调用都需要将用户空间的 fds 集合拷贝到内核空间，效率较低。
2. poll：Linux 内核 2.4 之后的版本，支持的文件描述符数量没有限制，但每次调用都需要将用户空间的 fds 集合拷贝到内核空间，效率较低。
3. epoll：Linux 内核 2.6 之后的版本，支持的文件描述符数量没有限制，采用事件驱动的方式，只有发生读写事件的文件描述符才会被内核通知，效率较高。